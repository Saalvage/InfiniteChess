@page "/"
@using MoonSharp.Interpreter
@using InfiniteChess.Shared
@using System.Text

<PageTitle>Index</PageTitle>

<style>
	.chess-board { border-spacing: 0; border-collapse: collapse; }
	.chess-board th { padding: .5em; }
	.chess-board th + th { border-bottom: 1px solid #000; }
	.chess-board th:first-child,
	.chess-board td:last-child { border-right: 1px solid #000; }
	.chess-board tr:last-child td { border-bottom: 1px solid; }
	.chess-board th:empty { border: none; }
	.chess-board td { width: 1.5em; height: 1.5em; text-align: center; font-size: 32px; line-height: 0;}
	.chess-board .light { background: #eee; }
	.chess-board .dark { background: #aaa; }
	.clicked.light { background: green; }
	.clicked.dark { background: darkgreen; }
	.can-move.light { background: lightskyblue; }
	.can-move.dark { background: blue; }
</style>

<table class="chess-board">
    <tbody>
    <tr>
	    <th></th>
		@for (var i = 0; i < _board.Pieces.GetLength(1); i++) {
			<th>
				@((char)('a' + i))
			</th>
		}
    </tr>
    @for (var row = _board.Pieces.GetLength(0) - 1; row >= 0; row--) {
	    <tr>
		    <th>@(row + 1)</th>
		    @for (var col = 0; col < _board.Pieces.GetLength(1); col++) {
			    var colCopy = col;
			    var rowCopy = row;
			    <td class="@((row + col) % 2 == 0 ? "light" : "dark") @(_visualClasses[colCopy, rowCopy])"
			        style="@(_board.Pieces[col, row] is { } piece ? $"background-image: url('{_pieces[piece.Name].GetImageUrl(piece.Color)}');" +
			                                                       $"background-size: contain;" : "")"
				@onclick="_ => ClickOn(colCopy, rowCopy)">
			    </td>
		    }
	    </tr>
	}
    </tbody>
</table>

<textarea cols="100" rows="20" @bind="_value">
function canMove(color, x, y, toX, toY)
	if BOARDS[1][toX][toY] == EMPTY_SQUARE then
		return true
	end
	return false
end
</textarea>

<button @onclick="Update">Poggers Button</button>

@_output

@code {
	private (int x, int y)? _clicked = null;

	private string[,] _visualClasses;

	private readonly Board _board = new(
	new Piece?[10,10]
	);

	private readonly Dictionary<string, PieceData> _pieces = new() {
		{"pawn", new() {ImageUrl = "img/pawn.svg", MoveScript = @"
	function canMove(color, x, y, toX, toY)
		if x == toX then
			if BOARD[toX][toY] ~= EMPTY_SQUARE then
				return false
			end

			if y + 1 == toY and color == WHITE or y - 1 == toY and color == BLACK then
				return true
			end

			if color == WHITE  and y == 2 and toY == 4 and BOARD[toX][3] == EMPTY_SQUARE
				or color == BLACK and y == BOARD_HEIGHT - 1 and toY == BOARD_HEIGHT - 3 and BOARD[toX][BOARD_HEIGHT - 2] == EMPTY_SQUARE then
				return true
			else
				return false
			end
		else
			-- TODO: en passant
			if BOARD[toX][toY] == EMPTY_SQUARE then
				return false
			else
				if BOARD[toX][toY].color ~= color and math.abs(x - toX) == 1
					and (color == WHITE and y + 1 == toY or color == BLACK and y - 1 == toY) then
					return true
				else
					return false
				end
			end
		end
	end
"}},
	};
	private Script _script;
	private string _value;
	private string _output;

	private readonly DynValue SCRIPT_WHITE = DynValue.NewNumber(1);
	private readonly DynValue SCRIPT_BLACK = DynValue.NewNumber(0);

	protected override void OnInitialized() {
		_board.Add(new("pawn", Piece.Colors.White), 6, 1);
		_board.Add(new("pawn", Piece.Colors.White), 4, 1);
		_board.Add(new("pawn", Piece.Colors.Black), 5, 8);

		_visualClasses = new string[_board.Pieces.GetLength(0), _board.Pieces.GetLength(1)];
		_visualClasses.Fill("");

		_script = new(CoreModules.Preset_HardSandbox) {
			Options = {
				Stdin = Stream.Null,
			},
		};
		_script.Globals.Set("WHITE", SCRIPT_WHITE);
		_script.Globals.Set("BLACK", SCRIPT_BLACK);
		_script.DoString(@"
			EMPTY_SQUARE = {}
			BOARD = {}
		");

		GenerateScriptBoard();
	}

	private void GenerateScriptBoard() {
		var sb = new StringBuilder();
		sb.AppendLine($"BOARD_WIDTH = {_board.Pieces.GetLength(0)}");
		sb.AppendLine($"BOARD_HEIGHT = {_board.Pieces.GetLength(1)}");
		for (var x = 0; x < _board.Pieces.GetLength(0); x++) {
			sb.AppendLine($"BOARD[{x + 1}] = {{}}");
			for (var y = 0; y < _board.Pieces.GetLength(1); y++) {
				if (_board.Pieces[x, y] is { } piece) {
					sb.AppendLine($"BOARD[{x + 1}][{y + 1}] = {{name = '{piece.Name}', color = {piece.Color:D}}}");
				} else {
					sb.AppendLine($"BOARD[{x + 1}][{y + 1}] = EMPTY_SQUARE");
				}
			}
		}
		_script.DoString(sb.ToString());
	}

	private void Update() {
		var test = _value.Trim();
		_script.DoString(_value.Trim());
		var canMove = _script.Call(_script.Globals["canMove"], 1, 1, 1, 1, 2).Boolean;
	}

	private void ClickOn(int x, int y) {
		if (_clicked != null && _visualClasses[x, y] == "can-move") {
			var (fromX, fromY) = _clicked.Value;
			_board.Pieces[x, y] = _board.Pieces[fromX, fromY];
			_board.Pieces[fromX, fromY] = null;
			_clicked = null;
			GenerateScriptBoard();
			_visualClasses.Fill("");
		} else {
			if (_board.Pieces[x, y] is { } piece) {
				if (_clicked != null) {
					var (oldX, oldY) = _clicked.Value;
					_visualClasses[oldX, oldY] = "";
					_clicked = null;
				}
				_clicked = (x, y);
				_script.DoString(_pieces[piece.Name].MoveScript);
				foreach (var (xi, yi) in EnumerateBoard()) {
					var canMove = _script.Call(_script.Globals["canMove"], piece.Color, x + 1, y + 1, xi + 1, yi + 1).Boolean;
					_visualClasses[xi, yi] = canMove ? "can-move" : "";
				}
				_visualClasses[x, y] = "clicked";
			} else {
				_visualClasses.Fill("");
			}
		}
	}

	private IEnumerable<(int x, int y)> EnumerateBoard() {
		for (var x = 0; x < _board.Pieces.GetLength(0); x++) {
			for (var y = 0; y < _board.Pieces.GetLength(1); y++) {
				yield return (x, y);
			}
		}
	}

}
